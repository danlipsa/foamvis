#include "VectorTensor.frag"
/**
 * @file   TensorDisplay.frag
 * @author Dan R. Lipsa
 *
 * Displays deformation ellipses
 */


// see Practical Linear Algebra, ch. 9
// BUG: Mac OS X 10.6.8 OpenGL driver does't like structures 
//      that end in a mat2.
struct Ellipse
{
    // r*d*transpose(r)
    mat2 m_a;
    // ellipse cMin, cMax which determine the size of the ellipse and the 
    // width of the line
    vec2 m_c;
};

const float sqrt2 = 1.41421356237;
const mat2 tensor45 = mat2 (3., 1., 1. / sqrt2, 1./ sqrt2);
const mat2 tensor_b264 = mat2 (
    0.00099301, 0.000340428,
    0.783351, 0.621579);
const mat2 transform45 = mat2 (2., 1., 1., 2.);
const mat2 transform_b264 = mat2 (
    7.4088e-04, 3.1775e-04, 3.1775e-04, 5.9256e-04);

void swap (inout float first, inout float second)
{
    float temp = first;
    first = second;
    second = temp;
}

vec2 getOrthogonal (vec2 v)
{
    return vec2 (v[1], -v[0]);
}

// see Numerical Recipes, ch 5.6
vec2 getQuadraticRoots (float a, float b, float c)
{
    float r = b * b - 4. * a * c;
    if (r < 0.0 || a == 0.0)
	discard;
    r = sqrt (r);
    float q = (-1.0 / 2.0) * (b + sign (b) * r);
    float first = q / a;
    float second = c / q;
    if (first < second)
	swap (first, second);
    return vec2 (first, second);
}

vec2 getEigenVector (float l, mat2 a)
{
    a[0][0] -= l;
    a[1][1] -= l;
    int i = (abs(a[0][0]) < abs(a[1][0])) ? 1 : 0;
    vec2 r = vec2 (-a[i][1] / a[i][0], 1.0);
    r = normalize (r);
    return r;
}

/**
 * returns true if the transform matrix is valid
 */
bool getTensor (vec2 texCoordCenter, out mat2 a)
{
    float count = texture2D (u_scalarAverageTexUnit, texCoordCenter).y;
    if (count == 0.0)
	return false;

    //debug
    //if (count == 1.0)
    //texCoordCenter = vec2 (0.5, 0.5);
    vec4 ta = texture2D (u_tensorAverageTexUnit, texCoordCenter);
    a = mat2 (ta[0], ta[1], ta[2], ta[3]);
    a = a / count;
    return true;
}

void clampTensorSize (inout vec2 eigenVal, float max)
{
    if (eigenVal[0] > max)
    {
	float ratio = max / eigenVal[0];
	eigenVal = ratio * eigenVal;
    }
}

vec2 calculateC (vec2 eigen)
{
    float middle = u_sizeRatio / u_gridCellLength;
    float width = u_lineWidth / eigen[1] / u_gridCellLength / 2;
    return vec2 (middle - width, middle + width);
}

Ellipse fromEigen (mat2 t)
{
    mat2 r = mat2 (t[1], getOrthogonal (t[1]));
    vec2 eigenVal = t[0];
    vec2 c = calculateC (eigenVal);
    clampTensorSize (eigenVal, 0.5 / c[1]);
    c = calculateC (eigenVal);
    vec2 l = vec2 (1. / (eigenVal[0] * eigenVal[0]), 
		   1. / (eigenVal[1] * eigenVal[1]));
    mat2 d = mat2 (l[0], 0., 0., l[1]);
    mat2 a = r * d * transpose (r);
    Ellipse e = Ellipse (a, vec2 (c[0] * c[0], c[1] * c[1]));
    // debug
    //e = Ellipse (mat2 (1./25., 0., 0., 1./9.), vec2 (1./25., 1./9.));
    return e;
}

Ellipse fromTensor (mat2 a)
{
    vec2 eVal = getQuadraticRoots (1.0, -a[0][0] - a[1][1],
				 a[0][0] * a[1][1] - a[0][1] * a[1][0]);
    vec2 eVec = getEigenVector (eVal[0], a);
    return fromEigen (mat2 (eVal, eVec));
}

void rotateTensor (inout mat2 a)
{
    mat2 r = mat2 (gl_ModelViewMatrix[0].xy, 
		   gl_ModelViewMatrix[1].xy);
    mat2 rInv = mat2 (gl_ModelViewMatrixInverse[0].xy, 
		      gl_ModelViewMatrixInverse[1].xy);
    a = r * a * rInv;
}


// x is in [0, 1)
bool isOnEllipse (vec2 x, vec2 texCoordCenter)
{
    mat2 a;
    if (getTensor (texCoordCenter, a))
    {
	//Ellipse t = fromEigen (tensor_b264);
	//Ellipse t = fromTensor (transform45);
	rotateTensor (a);
	Ellipse t = fromTensor (a);
	vec2 v = vec2 (0.5, 0.5);
	float value = dot (x - v, t.m_a * (x - v));
	return (t.m_c[0] <= value && value <= t.m_c[1]);
	//debug
	//return true;
    }
    else
	return false;
}

void main (void)
{
    const vec4 inkColor = vec4 (0., 0., 0., 1.);
    vec2 gridCoord, texCoordCenter;
    getCoordinates (gridCoord, texCoordCenter);
    vec2 gridCoordFract = fract (gridCoord);
    vec2 gridCoordFloor = floor (gridCoord);
    if (isOnEllipse (gridCoordFract, texCoordCenter) || 
        
	(u_gridShown && isOnGrid (gridCoordFract)) ||

	(u_gridShown && isOnGridCenter (gridCoord)) ||

	(u_gridCellCenterShown && 
	 isOnGridCellCenter (gridCoordFract, gridCoordFloor))
        )
	gl_FragColor = inkColor;
    else
	discard;
}


// Local Variables:
// mode: c++
// End:
