/**
 * Interface between flex and bison
 * @file   lexYacc.h
 * @author Dan R. Lipsa
 */
#ifndef _LEXYACC_H_
#define _LEXYACC_H_

#include <vector>
#include <string>
using namespace std;

/**
 * Defines the datatypes for semantic values for terminals and non-terminals
 * in the gramar
 */
class ExpressionTree;
typedef union
{
    /**
     * Semantic value for an iteger
     */
    int i;
    /**
     * Semantic value for a floating point
     */
    float r;
    /**
     * Semantic value for a list of integers
     */
    vector<int>* intList;
    string* id;
    ExpressionTree* node;
} SemanticValues;
/**
 * Defines the datatype for semantic values in bison to be yystype
 */
#define YYSTYPE SemanticValues

/**
 * Checks if an identifier is a keyword.
 * @param s identifier to be checked.
 * @return the keyword ID or 0 if `s' is not a keyword
 */
int KeywordId (char* s);


/**
 * Turns on or off flex debugging
 * @param debugging turns on debugging with 1 and turns off debugging with 0
 */
void FlexDebugging (int debugging);

/**
 * Turns on or off bison debugginig
 * @param debugging turns on debugging for 1, off for 0
 */
void BisonDebugging (int debugging);

/**
 * Standard bison function. Called when there is a 
 * parse error. I also call it for an error in the lexical analyzer.
 * @param error error message
 */
void yyerror (const char* error);

/**
 * Parser generated by bison from the description file foam.y
 * @return 0 for success, different than 0 otherwise
 */
int yyparse(void);

#endif

// Local Variables:
// mode: c++
// End:
