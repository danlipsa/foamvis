/**
 * @file main.cpp
 * @author Dan R. Lipsa
 *
 * Parses an Evolver DMP file and displays the data from the file.
 *
 * @todo Look at paths coresponding to bubbles around the circulation
 *       shown by average: Simon's email 21 Sep. 2012
 * @todo Add vorticity: Simon's email 21 Sep. 2012
 * @todo Implement VIEW_TRANSFORM, VIEW_TRANSFORM_GENERATORS, TRANSFORM_EXPR for
 *       twogascoarse dataset.
 * @todo Why time displacement does not go all the way to max Z?
 * @todo Use vertex arrays for center paths
 * @todo Use google-breakpad for reporting crashes.  
 * @todo Set new line significant only for list of vertices, edges,
 *       faces, bodies
 * @todo Replace vector + tensor drawing with geometry shader or CPU 
 *       (instead fragment shader)
 * @todo Optimization: for 2D foam, store vector count in the same texture
 *       instead of storing it in the scalar texture.
 * @todo Bug: velocity average shows a black blob if only one time step of data 
         is loaded. An error message should be shown instead.
 * @todo Bug: fix Overlay, Velocity, Glyph, Grid Cell Center.
 * @todo Bug: Translate grid does not work with streamlines.
 * @todo Fix the (slow) movement of the focus in context view for the GL view.
 * @todo Replace glScale with camera movement for GL view.
 * @todo Implement clamping such that the number of colors are not reduced
 *       for small clamp intervals.
 * @todo Add an option for 3D RegularGridAverage for AverageCountType::LOCAL. 
 *       This would be useful for shear160dumps_3b where a voxel does not have
 *       a value in every time steps.
 * @todo Use array indexes instead of pointers for faces part of a
 *       body, and vertices part of a face.
 *       This works better with VTK and with OpenGL vertex arrays.
 */

// ----------------------------------------------------------------------
/**
 * @mainpage FoamVis 
 *
 * FoamVis provides techniques for visualization, exploration and
 * analysis of time-dependent foam simulation data generated by
 * Surface Evolver. For requirements and instructions on how to
 * compile and execute the program see the @subpage readme file. For a
 * release log see the @subpage log file. For a high level overview of
 * the design and implementation of the program see the list of <a
 * href="modules.html">Modules</a>.
 *
 * @section download Download
 * Source files and libraries:
 * http://csgalati.swansea.ac.uk/foam/build
 *
 * Mac Os X binary release:
 * http://csgalati.swansea.ac.uk/foam/bin/mac-osx-10.6.8/
 *
 * @section sec_torus Processing done for the Torus model
 * @subsection sec_onedge Executed when creating an edge (may create duplicate vertices)
 *
 <pre>
The begin vertex (and the middle vertex in quadratic mode) of an edge is 
always defined in the data file (it's not a duplicate).
  if (edge is marked with a *)
    the end vertex is defined in the data file (no DUPLICATE needed)
  else if (edge is marked with a + or -) {
    create a DUPLICATE of the end vertex by translating it
      one domain up for a + and one domain down for a - along each of 
      the three axes. The translation is done relative to the domain where the 
      ORIGINAL end vertex is defined in the data file. This means that
      (* * *) is the domain where the begin vertex is defined in the data file
      NOT the original domain.
  }
 </pre>
 * 
 * @subsection sec_onface Executed when creating a face (may create duplicate edges)
 *
<pre>
  first vertex of the face is defined in the data file (not a DUPLICATE).
  set beginVertex to be the first vertex of the face
  foreach (currentEdge, edges in the face) {
    if (the beginVertex does not match the begin vertex of the currentEdge) {
      create a DUPLICATE of currentEdge starting at beginVertex
      set currentEdge to point to the DUPLICATE
    }
    set beginVertex  to be the end vertex of currentEdge
  }
</pre>
 * 
 * @subsection sec_onbody Executed when creating a body (may create duplicate faces)
 *
<pre>
Add all adjacent faces of face 0 to a queue.
while (no more items in the queue)
{
   remove a adjacent face, translate it if needed and mark it visited.
   if several faces fit, choose the face with smallest angle between its 
   normal and the original face normal.
}

</pre>
 *
 *
 * @section sec_physical_tesselation Physical and tesselation edges and vertices
 * In 2D we don't have physical edges. A vertex is "physical" if has
 * >= 3 edges adjacent to it.
 *
 * In 3D, an edge is physical if it has 6 AdjacentOrientedFace is part of. (is
 * adjacent with 3 faces)
 * An vertex is physical if it has 4 physical edges adjacent to it.
 *
 *
 * @section sec_space Significant space
 * For matrices of expressions and for vertex components
 * x, y, z.
 *
 * @section sec_new_line Significant new line
 * For arrays (2d versus 3d)
 *
 * @section sec_t1s Format of additional text file containing T1s
 * A line that starts with a # is a comment line @n
 * Each line contains three entries separated by space: time_step, x, y
 * where x and y are the coordinates of the T1 in object space @n
 * The first time step is 1. @n
 * A T1 labeled with timestep T occurs between T and T+1.@n
 *
 */

// ----------------------------------------------------------------------
/** 
 * @page readme ReadMe
 * @verbinclude README.txt
 */

// ----------------------------------------------------------------------
/** 
 * @page log Release Log
 * @verbinclude LOG.txt
 */


#include "Application.h"
#include "BrowseSimulations.h"
#include "Options.h"
#include "Debug.h"
#include "Foam.h"
#include "Simulation.h"
#include "ForceOneObject.h"
#include "ParsingData.h"
#include "MainWindow.h"

void readOptions (int argc, char *argv[],
		  CommandLineOptions* clo, 
		  vector< boost::shared_ptr<CommonOptions> >* co)
{
    try
    {
	clo->read (argc, argv);
    }
    // ignore if there no command line options, we'll read common options
    catch (const exception& e)
    {}

    try
    {
	size_t simulationsCount = clo->m_simulationIndexes.size ();
	if (simulationsCount == 0)
	{
	    if (! clo->m_iniFileName.empty ())
		// the user pressed cancel on the BrowseSimulations dialog
		exit (0);
	    simulationsCount = 1;
	    co->resize (1);
	    // read common options from the command line
	    (*co)[0].reset (new CommonOptions ());
	    (*co)[0]->read (argc, argv);
	}
	else
	{
	    // read common options from the ini file
	    co->resize (simulationsCount);
	    for (size_t i = 0; i < simulationsCount; ++i)
	    {
		string simulation = clo->m_names[clo->m_simulationIndexes[i]];
		cdbg << "Simulation name: " << simulation << " ...\n";
		(*co)[i].reset (new CommonOptions ());
		(*co)[i]->read (
		    clo->m_parametersArray[clo->m_simulationIndexes[i]],
		    clo->m_filter[i]);
	    }
	}
    }
    catch (const exception& e)
    {
	cdbg << "Exception reading common options: " << e.what () << endl;
	exit (13);
    }
}


void parseOptions (
    int argc, char *argv[], 
    boost::shared_ptr<SimulationGroup> simulationGroup, bool* outputText)
{
    CommandLineOptions clo;
    vector< boost::shared_ptr<CommonOptions> > co;
    readOptions (argc, argv, &clo, &co);
    size_t simulationsCount = co.size ();
    simulationGroup->SetSize (simulationsCount);
    for (size_t i = 0; i < simulationsCount; ++i)
    {
	Simulation& simulation = simulationGroup->GetSimulation (i);
        simulation.SetBoundingBoxAllTimeSteps (co[i]->m_simulationBoundingBoxAllTimeSteps);
	if (co[i]->m_vm.count (Option::m_name[Option::RESOLUTION]))
	    simulation.SetRegularGridResolution (co[i]->m_resolution);
	if (co[i]->m_vm.count (Option::m_name[Option::T1S]))
	    simulation.ParseT1s (
		co[i]->m_t1sFile, co[i]->m_ticksForTimeStep,
		co[i]->m_vm.count (Option::m_name[Option::T1S_LOWER]));
	simulation.ParseDMPs (
	    co[i]->m_fileNames, 
	    co[i]->m_vm.count (Option::m_name[Option::USE_ORIGINAL]),
	    co[i]->m_dmpObjectInfo, co[i]->m_forceNames,
	    clo.m_vm.count (Option::m_name[Option::DEBUG_PARSING]), 
	    clo.m_vm.count (Option::m_name[Option::DEBUG_SCANNING]));
	string simulationName = clo.m_names.empty () ?
	    LastDirFile (co[0]->m_fileNames[0].c_str ()) : 
            clo.m_names[clo.m_simulationIndexes[i]];
	simulation.SetName (simulationName);
	simulation.SetRotation2D (co[i]->m_rotation2D);
	simulation.SetReflectionAxis (co[i]->m_reflectionAxis);
	if (simulation.GetTimeSteps () == 0)
	{
	    cdbg << "Error: The patern provided does not match any file" 
		 << endl;
	    exit (13);
	}
	
	simulation.SetPressureAdjusted (
	    ! co[i]->m_vm.count (Option::m_name[Option::ORIGINAL_PRESSURE]));
	simulation.Preprocess ();
    }
    *outputText = clo.m_vm.count (Option::m_name[Option::OUTPUT_TEXT]);
}


/**
 * Parses the data file, reads in vertices, edges, etc and displays them.
 * @return 0 for success, different than 0 otherwise
 */
int main(int argc, char *argv[])
{
    QCoreApplication::setOrganizationName ("Swansea University");
    QCoreApplication::setOrganizationDomain ("www.swansea.ac.uk");
    QCoreApplication::setApplicationName ("FoamVis");
    /*cdbg << "min: " << numeric_limits<double>::min ()
	 << " max: " << numeric_limits<double>::max () << endl;
    */

    boost::shared_ptr<Application> app = Application::Get (argc, argv);
    bool outputText;
    try
    {
        boost::shared_ptr<SimulationGroup> simulationGroup (
            new SimulationGroup ());
	parseOptions (argc, argv, simulationGroup, &outputText);
	if (outputText)
	    cdbg << simulationGroup;
	else
	{
	    int result;
	    MainWindow window (simulationGroup);
	    window.show();
	    result = app->exec();
	    app->release ();
	    return result;
	}
	return 0;
    }
    catch (const exception& e)
    {
	cdbg << "Exception: " << e.what () << endl;
	exit (13);
    }
}
